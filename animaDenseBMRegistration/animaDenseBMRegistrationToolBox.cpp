// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaDenseBMRegistration.h"
#include "animaDenseBMRegistrationToolBox.h"

#include <QtGui>

#include <dtkCoreSupport/dtkAbstractProcessFactory.h>
#include <medAbstractRegistrationProcess.h>
#include <dtkCoreSupport/dtkSmartPointer.h>

#include <medRunnableProcess.h>
#include <medJobManagerL.h>

#include <medAbstractImageData.h>

#include <medToolBoxFactory.h>
#include <medRegistrationSelectorToolBox.h>
#include <medProgressionStack.h>
#include <medPluginManager.h>
#include <medToolBoxTab.h>

#include <rpiCommonTools.hxx>
#include <rpiAnimaDenseBMRegistration.h>

class animaDenseBMRegistrationToolBoxPrivate
{
public:
    
    //Block Initialisation Parameters
    QSpinBox *blockSize;
    QSpinBox *blockSpacing;
    QDoubleSpinBox *stdThreshold;
    QDoubleSpinBox *percentageKept;

    //Block Match Parameters
    QComboBox *transform;
    QComboBox * metric;
    QComboBox * optimizer;
    QSpinBox *maxIterations;
    QDoubleSpinBox * minError;
    QSpinBox *optIterations;
    QDoubleSpinBox * searchRadius;
    QDoubleSpinBox * searchAngleRadius;
    QDoubleSpinBox * searchScaleRadius;
    QDoubleSpinBox * finalRadius;
    QDoubleSpinBox * stepSize;
    QDoubleSpinBox * translateUpperBound;
    QDoubleSpinBox * angleUpperBound;
    QDoubleSpinBox * scaleUpperBound;

    //Agregation Parameters:
    QComboBox *agregator;
    QDoubleSpinBox *extrapolationSigma;
    QDoubleSpinBox *elasticSigma;
    QDoubleSpinBox *outlierSigma;
    QDoubleSpinBox *mEstimateConvergenceThreshold;
    QDoubleSpinBox *neighborhoodApproximation;
    
    //Pyramid parameters:
    QSpinBox *pyramidLevels;
    QSpinBox *lastLevel;
    
    //Global Parameters:
    QSpinBox *threads;

    medProgressionStack * progression_stack;
};

animaDenseBMRegistrationToolBox::animaDenseBMRegistrationToolBox(QWidget *parent) : medAbstractSelectableToolBox(parent), d(new animaDenseBMRegistrationToolBoxPrivate)
{
    //QWidget *widget = new QWidget(this);
    //QToolBox *widget = new QToolBox(this);
    medToolBoxTab *widget = new medToolBoxTab(this);

    QPushButton *runButton = new QPushButton(tr("Run"), this);

    this->setTitle("Pyramidal BM Registration");

    // progression stack
    d->progression_stack = new medProgressionStack(widget);
    QHBoxLayout *progressStackLayout = new QHBoxLayout;
    progressStackLayout->addWidget(d->progression_stack);
    
    // Block Initialisation Parameters
    d->blockSize = new QSpinBox;
    d->blockSize->setToolTip("Size of the blocks");
    d->blockSize->setValue(5);
    
    d->blockSpacing = new QSpinBox;
    d->blockSpacing->setToolTip("Spacing between blocks");
    d->blockSpacing->setValue(2);
    
    d->stdThreshold = new QDoubleSpinBox;
    d->stdThreshold->setToolTip("Threshold block standard deviation");
    d->stdThreshold->setValue(5);
    
    d->percentageKept = new QDoubleSpinBox;
    d->percentageKept->setToolTip("Percentage of blocks actually used");
    d->percentageKept->setValue(0.8);
    d->percentageKept->setRange(0,1);
    d->percentageKept->setSingleStep(0.01);

    // Block Match Parameters
    d->transform = new QComboBox;
    d->transform->setToolTip("Transformation computed between blocks");
    QStringList transformList;
    transformList << "Translation" << "Rigid" << "Affine";
    d->transform->addItems ( transformList );
    
    d->metric = new QComboBox;
    d->metric->setToolTip("Similarity metric between blocks");
    QStringList metricList;
    metricList << "SquaredCorrelation" << "Correlation" << "MeanSquares";
    d->metric->addItems ( metricList );
    
    d->optimizer = new QComboBox;
    d->optimizer->setToolTip("Optimizer for optimal block search");
    QStringList optimizerList;
    optimizerList << "Exhaustive" << "Bobyqa";
    d->optimizer->addItems ( optimizerList );
    d->optimizer->setCurrentIndex(1);
    
    d->maxIterations = new QSpinBox;
    d->maxIterations->setToolTip("Maximum Block Match Iteration");
    d->maxIterations->setValue(10);
    
    d->minError = new QDoubleSpinBox;
    d->minError->setToolTip("Minimal distance between consecutive estimated transforms");
    d->minError->setDecimals(3);
    d->minError->setValue(0.01);   
    d->minError->setSingleStep(0.001);
    
    d->optIterations = new QSpinBox;
    d->optIterations->setToolTip("Maximum Local Optimizer Iterations");
    d->optIterations->setRange(0,10000);
    d->optIterations->setValue(100);
    
    d->searchRadius = new QDoubleSpinBox;
    d->searchRadius->setToolTip("The search radius (exhaustive search window, rho start for newuoa");
    d->searchRadius->setValue(1);
    
    d->searchAngleRadius = new QDoubleSpinBox;
    d->searchAngleRadius->setToolTip("The search angle radius (rho start for newuoa on angles part)");
    d->searchAngleRadius->setValue(5);
    
    d->searchScaleRadius = new QDoubleSpinBox;
    d->searchScaleRadius->setToolTip("The search scale radius (rho start for newuoa on scales part)");
    d->searchScaleRadius->setValue(0.1);
    d->searchScaleRadius->setSingleStep(0.01);

    d->finalRadius = new QDoubleSpinBox;
    d->finalRadius->setToolTip("The final radius (rho end for newuoa)");
    d->finalRadius->setDecimals(4);
    d->finalRadius->setValue(0.001);
    d->finalRadius->setSingleStep(0.0001);
    
    d->stepSize = new QDoubleSpinBox;
    d->stepSize->setToolTip("The  stepping size (for exhaustive search)");
    d->stepSize->setValue(1);

    d->translateUpperBound = new QDoubleSpinBox;
    d->translateUpperBound->setToolTip("The upper bound on translation for bobyqa (in voxels)");
    d->translateUpperBound->setValue(10);
    
    d->angleUpperBound = new QDoubleSpinBox;
    d->angleUpperBound->setToolTip("The upper bound on angles for bobyqa (in degrees)");
    d->angleUpperBound->setRange(0,180);
    d->angleUpperBound->setValue(180);
    
    d->scaleUpperBound = new QDoubleSpinBox;
    d->scaleUpperBound->setToolTip("The upper bound on scales for bobyqa");
    d->scaleUpperBound->setValue(3);

    // Agregation Parameters:
    d->agregator = new QComboBox;
    d->agregator->setToolTip("Type of Agregator");
    QStringList agregatorList;
    agregatorList << "Baloo" << "MSmoother";
    d->agregator->addItems ( agregatorList );
    
    d->extrapolationSigma = new QDoubleSpinBox;
    d->extrapolationSigma->setToolTip("Sigma for dense field extrapolation (similar to fluid regularization)");
    d->extrapolationSigma->setValue(3.0);
    d->extrapolationSigma->setDecimals(2);
    d->extrapolationSigma->setSingleStep(0.01);
    
    d->elasticSigma = new QDoubleSpinBox;
    d->elasticSigma->setToolTip("Sigma for transformation elastic smoothing");
    d->elasticSigma->setValue(3.0);
    d->elasticSigma->setDecimals(2);
    d->elasticSigma->setSingleStep(0.01);
    
    d->outlierSigma = new QDoubleSpinBox;
    d->outlierSigma->setToolTip("Sigma for outlier rejection");
    d->outlierSigma->setValue(3.0);
    d->outlierSigma->setDecimals(2);
    d->outlierSigma->setSingleStep(0.01);
    
    d->mEstimateConvergenceThreshold = new QDoubleSpinBox;
    d->mEstimateConvergenceThreshold->setToolTip("M-smoother convergence threshold");
    d->mEstimateConvergenceThreshold->setValue(0.01);
    d->mEstimateConvergenceThreshold->setDecimals(3);
    d->mEstimateConvergenceThreshold->setSingleStep(0.001);
    
    d->neighborhoodApproximation = new QDoubleSpinBox;
    d->neighborhoodApproximation->setToolTip("M-smoother neighborhood approximation (considers only that distance in pixels as the neighborhood)");
    d->neighborhoodApproximation->setValue(2.5);
    d->neighborhoodApproximation->setDecimals(2);
    d->neighborhoodApproximation->setSingleStep(0.01);
    
    // Pyramid parameters:
    d->pyramidLevels = new QSpinBox;
    d->pyramidLevels->setToolTip("Number of pyramid levels");
    d->pyramidLevels->setValue(3);
    
    d->lastLevel = new QSpinBox;
    d->lastLevel->setToolTip("Index of the last pyramid level explored (0 is full resolution)");
    d->lastLevel->setValue(0);
    
     
    // Global Parameters:  
    d->threads = new QSpinBox;
    d->threads->setToolTip("Number of Execution Threads");
    d->threads->setValue(itk::MultiThreaderBase::GetGlobalDefaultNumberOfThreads());
    d->threads->setRange(1, itk::MultiThreaderBase::GetGlobalDefaultNumberOfThreads());

    // Block Initialisation Parameters Layout
    QFormLayout *blockInitLayout = new QFormLayout();
    blockInitLayout->addRow(new QLabel(tr("Block size"),this),d->blockSize);
    blockInitLayout->addRow(new QLabel(tr("Block spacing"),this),d->blockSpacing);
    blockInitLayout->addRow(new QLabel(tr("Std Threshold"),this),d->stdThreshold);
    blockInitLayout->addRow(new QLabel(tr("Percentage kept"),this),d->percentageKept);

    QGroupBox *blockInitGroupBox = new QGroupBox(tr("Block Initialisation Parameters"));
    blockInitGroupBox->setLayout(blockInitLayout);


    // Block Match Parameters Layout
    QFormLayout *blockMatchLayout = new QFormLayout();
    blockMatchLayout->addRow(new QLabel(tr("Transform"),this),d->transform);
    blockMatchLayout->addRow(new QLabel(tr("Metric"),this),d->metric);
    blockMatchLayout->addRow(new QLabel(tr("Optimizer"),this),d->optimizer);
    blockMatchLayout->addRow(new QLabel(tr("Max Iterations"),this),d->maxIterations);
    blockMatchLayout->addRow(new QLabel(tr("Min error"),this),d->minError);
    blockMatchLayout->addRow(new QLabel(tr("Optimizer Iterations"),this),d->optIterations);
    blockMatchLayout->addRow(new QLabel(tr("Search Radius"),this),d->searchRadius);
    blockMatchLayout->addRow(new QLabel(tr("Search Angle Radius"),this),d->searchAngleRadius);
    blockMatchLayout->addRow(new QLabel(tr("Seardch Scale Radius"),this),d->searchScaleRadius);
    blockMatchLayout->addRow(new QLabel(tr("Final Radius"),this),d->finalRadius);
    blockMatchLayout->addRow(new QLabel(tr("Step Size"),this),d->stepSize);
    blockMatchLayout->addRow(new QLabel(tr("Translate Upper"),this),d->translateUpperBound);
    blockMatchLayout->addRow(new QLabel(tr("Angle Upper"),this),d->angleUpperBound);
    blockMatchLayout->addRow(new QLabel(tr("Scale Upper"),this),d->scaleUpperBound);

    QGroupBox *blockMatchGroupBox = new QGroupBox(tr("Block Match Parameters"));
    blockMatchGroupBox->setAutoFillBackground(false);
    blockMatchGroupBox->setBackgroundRole(this->backgroundRole());
    blockMatchGroupBox->setLayout(blockMatchLayout);
    blockMatchGroupBox->setForegroundRole(this->foregroundRole());
    
    // Agregation Parameters Layout
    QFormLayout *agregationParamLayout = new QFormLayout();
    agregationParamLayout->addRow(new QLabel(tr("Agregator"),this),d->agregator);
    agregationParamLayout->addRow(new QLabel(tr("Extrapolation Sigma"),this),d->extrapolationSigma);
    agregationParamLayout->addRow(new QLabel(tr("Elastic Sigma"),this),d->elasticSigma);
    agregationParamLayout->addRow(new QLabel(tr("Outlier Sigma"),this),d->outlierSigma);
    agregationParamLayout->addRow(new QLabel(tr("M-smoother Threshold"),this),d->mEstimateConvergenceThreshold);
    agregationParamLayout->addRow(new QLabel(tr("M-smoother Neighborhood"),this),d->neighborhoodApproximation);
    
    QGroupBox *agregationParamGroupBox = new QGroupBox(tr("Agregation Parameters"));
    agregationParamGroupBox->setLayout(agregationParamLayout);
    
    // Pyramid Parameters Layout   
    QFormLayout *pyramidParamLayout = new QFormLayout();
    pyramidParamLayout->addRow(new QLabel(tr("Pyramid Levels"),this),d->pyramidLevels);
    pyramidParamLayout->addRow(new QLabel(tr("Last Level"),this),d->lastLevel);

    QGroupBox *pyramidParamGroupBox = new QGroupBox(tr("Pyramid Parameters"));
    pyramidParamGroupBox->setLayout(pyramidParamLayout);
    
    // Global Parameters Layout 
    QFormLayout *globalParamLayout = new QFormLayout();
    globalParamLayout->addRow(new QLabel(tr("Threads"),this),d->threads);

    QGroupBox *globalParamGroupBox = new QGroupBox(tr("Global Parameters"));
    globalParamGroupBox->setLayout(globalParamLayout);
    
    QWidget *header = new QWidget;
    QVBoxLayout *layoutheader = new QVBoxLayout(header);   
    layoutheader->addWidget(runButton);
    layoutheader->addWidget(d->progression_stack);
    
    QWidget *page1 = new QWidget;
    QVBoxLayout *layout1 = new QVBoxLayout(page1);
    layout1->addWidget(blockInitGroupBox);
    layout1->addWidget(agregationParamGroupBox);
    layout1->addWidget(pyramidParamGroupBox);
    layout1->addWidget(globalParamGroupBox);
     
    QWidget *page2 = new QWidget;
    QVBoxLayout *layout2 = new QVBoxLayout(page2);
    layout2->addWidget(blockMatchGroupBox);
  
    widget->addTab(page1, "Main");
    widget->addTab(page2, "Block Match Parameters ");
   
    this->addWidget( header );
    this->addWidget( widget );

    connect(runButton, SIGNAL(clicked()), this, SLOT(run()));
    
    connect(d->optimizer, SIGNAL(currentIndexChanged(int)), this, SLOT(updateBMOptimizerParams(int)));
    connect(d->transform, SIGNAL(currentIndexChanged(int)), this, SLOT(updateBMTransformParams(int)));
    connect(d->agregator, SIGNAL(currentIndexChanged(int)), this, SLOT(updateBMAgregatorParams(int)));
    
    updateBMOptimizerParams(0);
    updateBMTransformParams(0);
    updateBMAgregatorParams(0);
    
    // Add about plugin
    medPluginManager* pm = medPluginManager::instance();
    dtkPlugin* plugin = pm->plugin ( "animaDenseBMRegistrationPlugin" );
    setAboutPluginButton ( plugin );
    setAboutPluginVisibility( true );
}

animaDenseBMRegistrationToolBox::~animaDenseBMRegistrationToolBox(void)
{
    delete d;
    
    d = NULL;
}

dtkPlugin * animaDenseBMRegistrationToolBox::plugin()
{
	medPluginManager* pm = medPluginManager::instance();
	dtkPlugin* plugin = pm->plugin("Dense Anatomical BM Registrations");
	return plugin;
}

bool animaDenseBMRegistrationToolBox::registered(void)
{
    return medToolBoxFactory::instance()->
    registerToolBox<animaDenseBMRegistrationToolBox>();
}


medAbstractData * animaDenseBMRegistrationToolBox::processOutput()
{
    // If called from pipelines, and run() not called before.
    if ( static_cast<medRegistrationSelectorToolBox*>(selectorToolBox())->process() == nullptr)
    {
        run();
    }

    if (static_cast<medRegistrationSelectorToolBox*>(selectorToolBox())->process() != nullptr)
    {
        return static_cast<medRegistrationSelectorToolBox*>(selectorToolBox())->process()->output();
    }
    else
    {
        return nullptr;
    }
}

void animaDenseBMRegistrationToolBox::run(void)
{ 
	medRegistrationSelectorToolBox *parentTB = dynamic_cast<medRegistrationSelectorToolBox*>(selectorToolBox());
	dtkSmartPointer <medAbstractRegistrationProcess> process;

    if(parentTB == nullptr)
        return;    

    if (parentTB->process() &&
        (parentTB->process()->identifier() == "animaDenseBMRegistration"))
    {
        process = parentTB->process();
    }
    else
    {
        process = dtkAbstractProcessFactory::instance()->createSmartPointer("animaDenseBMRegistration");

		parentTB->setProcess(process);
    }
    
    dtkSmartPointer<medAbstractData> fixedData  = parentTB->fixedData();
    dtkSmartPointer<medAbstractData> movingData = parentTB->movingData();
    
    if (!fixedData || !movingData)
        return;
    
    animaDenseBMRegistration *process_Registration = dynamic_cast<animaDenseBMRegistration *>(process.data());
    if (!process_Registration)
    {
        qWarning() << "registration process doesn't exist" ;
        return;
    }

    // Setting process arguments
    process_Registration->setBlockSize( d->blockSize->value() );
    process_Registration->setBlockSpacing( d->blockSpacing->value() );
    process_Registration->setPercentageKept( d->percentageKept->value() );
    process_Registration->setStDevThreshold( d->stdThreshold->value() );
    process_Registration->setTransform( d->transform->currentIndex() );
    process_Registration->setMetric( d->metric->currentIndex() );
    process_Registration->setOptimizer( d->optimizer->currentIndex() );
    process_Registration->setMaximumIterations( d->maxIterations->value() );
    process_Registration->setMinimalTransformError( d->minError->value() );
    process_Registration->setOptimizerMaximumIterations( d->optIterations->value() );
    process_Registration->setSearchRadius( d->searchRadius->value() );
    process_Registration->setSearchAngleRadius( d->searchAngleRadius->value() );
    process_Registration->setSearchScaleRadius( d->searchScaleRadius->value() );
    process_Registration->setStepSize( d->stepSize->value() );
    process_Registration->setTranslateUpperBound( d->translateUpperBound->value() );
    process_Registration->setAngleUpperBound( d->angleUpperBound->value() );
    process_Registration->setScaleUpperBound( d->scaleUpperBound->value() );
    process_Registration->setAgregator( d->agregator->currentIndex() );
    process_Registration->setExtrapolationSigma (d->extrapolationSigma->value());
    process_Registration->setElasticSigma (d->elasticSigma->value());
    process_Registration->setOutlierSigma (d->outlierSigma->value());
    process_Registration->setMEstimateConvergenceThreshold(d->mEstimateConvergenceThreshold->value());
    process_Registration->setNeighborhoodApproximation(d->neighborhoodApproximation->value());
    process_Registration->setNumberOfPyramidLevels( d->pyramidLevels->value() );
    process_Registration->setLastPyramidLevel( d->lastLevel->value() );
    process_Registration->setNumberOfThreads( d->threads->value() );
    
    process->setFixedInput(fixedData);
    process->setMovingInput(movingData);
    
    medRunnableProcess *runProcess = new medRunnableProcess;
    runProcess->setProcess (process);
    
    d->progression_stack->addJobItem(runProcess, tr("Progress:"));
    //If there is no observer to track the progression,
    //make the progress bar spin:
    //d->progression_stack->setActive(runProcess,true);
    
    connect (runProcess, SIGNAL (success  (QObject*)),  this, SIGNAL (success ()));
    connect (runProcess, SIGNAL (failure  (QObject*)),  this, SIGNAL (failure ()));
    connect (runProcess, SIGNAL (cancelled (QObject*)), this, SIGNAL (failure ()));
    //First have the moving progress bar,
    //and then display the remaining % when known
    connect (runProcess, SIGNAL(activate(QObject*,bool)),
             d->progression_stack, SLOT(setActive(QObject*,bool)));
    
    medJobManagerL::instance()->registerJobItem(runProcess);
    QThreadPool::globalInstance()->start(dynamic_cast<QRunnable*>(runProcess));
}

void animaDenseBMRegistrationToolBox::updateBMOptimizerParams(int index)
{
    typedef typename animaDenseBMRegistration::RegistrationType::BMRegistrationType BMRegistrationType;
    typedef typename BMRegistrationType::Optimizer Optimizer;

    Optimizer opt = (Optimizer) d->optimizer->currentIndex();

    d->translateUpperBound->setEnabled( opt == BMRegistrationType::Bobyqa );
    d->angleUpperBound->setEnabled( d->angleUpperBound->isEnabled() && opt == BMRegistrationType::Bobyqa );
    d->scaleUpperBound->setEnabled( d->scaleUpperBound->isEnabled() && opt == BMRegistrationType::Bobyqa );
    
    d->stepSize->setEnabled( opt == BMRegistrationType::Exhaustive);
    
    d->searchAngleRadius->setEnabled(d->searchAngleRadius->isEnabled() && opt != BMRegistrationType::Exhaustive );
    d->searchScaleRadius->setEnabled(d->searchScaleRadius->isEnabled() && opt != BMRegistrationType::Exhaustive );
    
    d->finalRadius->setEnabled( opt != BMRegistrationType::Exhaustive );
}

void animaDenseBMRegistrationToolBox::updateBMTransformParams(int index)
{
    typedef typename animaDenseBMRegistration::RegistrationType::BMRegistrationType BMRegistrationType;
    typedef typename BMRegistrationType::Transform Transform;

    Transform tr = (Transform) d->transform->currentIndex();
    
    d->searchAngleRadius->setEnabled(tr == BMRegistrationType::Affine || tr == BMRegistrationType::Rigid);
    d->angleUpperBound->setEnabled( tr == BMRegistrationType::Affine || tr == BMRegistrationType::Rigid);
    
    d->searchScaleRadius->setEnabled(tr == BMRegistrationType::Affine);
    d->scaleUpperBound->setEnabled(tr == BMRegistrationType::Affine);
}

void animaDenseBMRegistrationToolBox::updateBMAgregatorParams(int index)
{
    typedef typename animaDenseBMRegistration::RegistrationType::BMRegistrationType BMRegistrationType;
    typedef typename BMRegistrationType::Agregator Agregator;

    Agregator agreg = (Agregator) d->agregator->currentIndex();
    
    d->mEstimateConvergenceThreshold->setEnabled(agreg == BMRegistrationType::MSmoother);
    d->neighborhoodApproximation->setEnabled(agreg == BMRegistrationType::MSmoother);
}
